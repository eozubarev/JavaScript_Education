// Объекты / простые объекты» («plain objects»)
// https://learn.javascript.ru/object

// Объекты используются для хранения коллекций различных значений и более сложных сущностей.

const user = { // литеральный синтаксис {...}
    name: 'Jenya',
    age: 25,
    lastName: 'Markov',
    skils: ['html', 'css', 'js'],
    'likes birds' : true,
}




// Мы можем в любой момент добавить в него новые папки, удалить папки или прочитать содержимое любой папки.
// Обращения к свойствам
console.log( user.name ); 
console.log( user.age );




// Значение может быть любого типа. 
user.isProgrammer = false;
console.log( user )




// Объект, объявленный как константа, может быть изменён / пример 19 строка.
// объявление const защищает от изменений только саму переменную user, а не её содержимое.




// Квадратные скобки
// Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает:
// user.likes birds = true // это вызовет синтаксическую ошибку

// получение значения свойства
alert(user["likes birds"]); // true

// Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения.
// Например, имя свойства может храниться в переменной:
let key = "likes birds";

// то же самое, что и user["likes birds"] = true;
user[key] = true;




// Свойство из переменной
// В реальном коде часто нам необходимо использовать существующие переменные как значения для свойств с тем же именем.
function makeUser(name, age) {
    return {
        name: name,
        age: age
        // ...другие свойства
    };
}

let user = makeUser("John", 30);
alert(user.name); // John




// Ограничения на имена свойств
// Имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д.
// эти имена свойств допустимы
let obj = {
    for: 1,
    let: 2,
    return: 3
};

alert( obj.for + obj.let + obj.return );  // 6

//Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов
// Все другие типы данных будут автоматически преобразованы к строке.
// Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0":
let obj = {
    0: "Тест" // то же самое что и "0": "Тест"
};

// Есть небольшой подводный камень, связанный со специальным свойством __proto__.
// Мы не можем установить его в необъектное значение:
let obj = {};
obj.__proto__ = 5; // присвоим число
alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали




// Проверка существования свойства, оператор «in»
// В отличие от многих других языков, особенность JavaScript-объектов в том,
// что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет!
// При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:
let user = {};
alert( user.noSuchProperty === undefined ); // true означает "свойства нет"

// Также существует специальный оператор "in" для проверки существования свойства в объекте.

"key" in object

let user2 = { name: "John", age: 30 };
alert( "age" in user2 ); // true, user.age существует
alert( "blabla" in user2 ); // false, user.blabla не существует
// слева от оператора in должно быть имя свойства. Обычно это строка в кавычках.

// Если мы опускаем кавычки, это значит, что мы указываем переменную, в которой находится имя свойства. Например:
let user3 = { age: 30 };
let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key




// Цикл "for..in"
// Для перебора всех свойств объекта используется цикл for..in.
// Этот цикл отличается от изученного ранее цикла for(;;).
for (key in object) {
    // тело цикла выполняется для каждого свойства объекта
}

let user3 = {
    name: "John",
    age: 30,
    isAdmin: true
};

for (let key in user3) {
    // ключи
    alert( key );  // name, age, isAdmin
    // значения ключей
    alert( user3[key] ); // John, 30, true
}




// Упорядочение свойств объекта
// Упорядочены ли свойства объекта? Другими словами, если мы будем в цикле
// перебирать все свойства объекта, получим ли мы их в том же порядке, в котором мы их добавляли?

// Можем ли мы на это рассчитывать?
// Короткий ответ: свойства упорядочены особым образом: свойства с целочисленными
// ключами сортируются по возрастанию, остальные располагаются в порядке создания. Разберёмся подробнее.
let codes = {
    "49": "Германия",
    "41": "Швейцария",
    "44": "Великобритания",
    // ..,
    "1": "США"
};

for (let code in codes) {
    alert(code); // 1, 41, 44, 49
}

// …С другой стороны, если ключи не целочисленные, то они перебираются в порядке создания, например:
let user4 = {
    name: "John",
    surname: "Smith"
};
user4.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user4) {
    alert( prop ); // name, surname, age
}

// Таким образом, чтобы решить нашу проблему с телефонными кодами, мы можем схитрить,
// сделав коды не целочисленными свойствами. Добавления знака "+" перед каждым кодом будет достаточно.
let codes2 = {
    "+49": "Германия",
    "+41": "Швейцария",
    "+44": "Великобритания",
    // ..,
    "+1": "США"
};

for (let code in codes2) {
    alert( +code ); // 49, 41, 44, 1
}