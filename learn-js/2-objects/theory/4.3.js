// Методы объекта, "this"
// https://learn.javascript.ru/object-methods

let user = {
    name: 'Jenya',
    age: 25,
    skils: ['html', 'css', 'react'],
}

user.sayHello = function () {
    alert('Привет')
}

// Здесь мы просто использовали Function Expression (функциональное выражение),
// чтобы создать функцию приветствия, и присвоили её свойству user.sayHi нашего объекта.
// Затем мы можем вызвать ee как user.sayHi(). Теперь пользователь может говорить!
// Функцию, которая является свойством объекта, называют методом этого объекта.
//  Итак, мы получили метод sayHi объекта user.

// Сокращённая запись метода
user = {
    sayHi() { // то же самое, что и "sayHi: function(){...}"
        alert("Hi");
    }
};




// Ключевое слово «this» в методах
// Значение this – это объект «перед точкой», который используется для вызова метода.
let user2 = {
    name: "John",
    age: 30,

    sayHi() {
        // "this" - это "текущий объект".
        alert(this.name);
    }

};

user2.sayHi(); // John


// Технически также возможно получить доступ к объекту без ключевого слова this,
// обратившись к нему через внешнюю переменную (в которой хранится ссылка на этот объект):

let use3 = {
    name: "John",
    age: 30,

    sayHi() {
        alert(use3.name); // "user" вместо "this"
    }

};

// …Но такой код ненадёжен. Если мы решим скопировать ссылку на объект user в другую переменную, например,
//  admin = user, и перезапишем переменную user чем-то другим, тогда будет осуществлён доступ к неправильному
// объекту при вызове метода из admin.

let user4 = {
    name: "John",
    age: 30,

    sayHi() {
        alert( user4.name ); // приведёт к ошибке
    }

};


let admin = user4;
user4 = null; // перезапишем переменную для наглядности, теперь она не хранит ссылку на объект.

admin.sayHi(); // TypeError: Cannot read property 'name' of null

// Если бы мы использовали this.name вместо user.name внутри alert, тогда этот код бы сработал.




// «this» не является фиксированным

// В JavaScript ключевое слово «this» ведёт себя иначе, чем в большинстве других языков программирования.
// Его можно использовать в любой функции, даже если это не метод объекта.
// В следующем примере нет синтаксической ошибки:
let user5 = { name: "John" };
let admin = { name: "Admin" };

function sayHi2() {
    alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user5.f = sayHi2;
admin.f = sayHi2;

// эти вызовы имеют  разное значение this
// "this" внутри функции - это объект "перед точкой"
user5.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (нет разницы между использованием точки или квадратных скобок для доступа к объекту)

//Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj.
// Так что, в приведённом выше примере это либо user, либо admin.

// Вызов без объекта: this == undefined
//Мы даже можем вызвать функцию вообще без объекта:

    function sayHi3() {
        alert(this);
    }

sayHi3(); // undefined




// В JavaScript this является «свободным», его значение вычисляется в момент
// вызова метода и не зависит от того, где этот метод был объявлен,
// а скорее от того, какой объект вызывает метод (какой объект стоит «перед точкой»).

// Эта концепция вычисления this в момент исполнения имеет как свои плюсы, так и минусы.
// С одной стороны, функция может быть повторно использована в
// качестве метода у различных объектов (что повышает гибкость). С другой стороны, большая
// гибкость увеличивает вероятность ошибок.