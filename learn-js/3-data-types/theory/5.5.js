// https://learn.javascript.ru/array-methods
// Методы массивов



// splice
// синтаксис: arr.splice(index[, deleteCount, elem1, ..., elemN])
// это универсальный «швейцарский нож» для работы с массивами.
// Умеет всё: добавлять, удалять и заменять элементы.

const arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
console.log( arr ); // осталось ["Я", "JavaScript"]

const arr2 = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr2.splice(0, 3, "Давай", "танцевать");
console.log( arr2 ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
let arr3 = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr3.splice(2, 0, "сложный", "язык");
console.log( arr3 ); // "Я", "изучаю", "сложный", "язык", "JavaScript"




// slice
// синтаксис: arr.slice([start], [end])
//Он возвращает новый массив, в который копирует элементы, начиная с индекса start и до end (не включая end).
//Оба индекса start и end могут быть отрицательными. В таком случае отсчёт будет осуществляться с конца массива.
let arr4 = ["t", "e", "s", "t"];
console.log( arr4.slice(1, 3) ); // e,s (копирует с 1 до 3)
console.log( arr4.slice(-2) ); // s,t (копирует с -2 до конца)

// Можно вызвать slice и вообще без аргументов: arr.slice() создаёт копию массива arr.




// concat
// синтаксис arr.concat(arg1, arg2...)
// Он принимает любое количество аргументов, которые могут быть как массивами, так и простыми значениями.
// В результате мы получаем новый массив, включающий в себя элементы из arr, а также arg1, arg2 и так далее…
// Если аргумент argN – массив, то все его элементы копируются. Иначе скопируется сам аргумент.

const arr5 = [1, 2];
// создать массив из: arr5 и [3,4]
console.log( arr5.concat([3, 4]) ); // 1,2,3,4
// создать массив из: arr5 и [3,4] и [5,6]
console.log( arr5.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
// создать массив из: arr5 и [3,4], потом добавить значения 5 и 6
console.log( arr5.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6




// forEach
// синтаксис
// arr.forEach(function(item, index, array) {
//     // ... делать что-то с item
// });




// Методы для поиска элементов в массиве

// indexOf/lastIndexOf и includes
// Методы arr.indexOf, arr.lastIndexOf и arr.includes имеют одинаковый синтаксис и делают по сути
// то же самое, что и их строковые аналоги, но работают с элементами вместо символов:


// arr.indexOf(item, from)
// ищет item, начиная с индекса from, и возвращает индекс,
// на котором был найден искомый элемент, в противном случае -1.

// arr.lastIndexOf(item, from)
// то же самое, но ищет справа налево.

// arr.includes(item, from)
// ищет item, начиная с индекса from, и возвращает true, если поиск успешен.

const arr6 = [1, 0, false];

console.log( arr6.indexOf(0) ); // 1
console.log( arr6.indexOf(false) ); // 2
console.log( arr6.indexOf(null) ); // -1

console.log( arr6.includes(1) ); // true

// методы используют строгое сравнение ===.
// Таким образом, если мы ищем false, он находит именно false, а не ноль.

// Если мы хотим проверить наличие элемента, и нет необходимости знать его точный
// индекс, тогда предпочтительным является arr.includes.




// find и findIndex
// синтаксис:
const result = arr.find(function(item, index, array) {
    // если true - возвращается текущий элемент и перебор прерывается
    // если все итерации оказались ложными, возвращается undefined
});

// Если функция возвращает true, поиск прерывается и возвращается item.
// Если ничего не найдено, возвращается undefined.




// filter
// На тот случай, если найденных элементов может быть много, предусмотрен метод arr.filter(fn).
// Синтаксис этого метода схож с find, но filter возвращает массив из всех подходящих элементов:
const results2 = arr.filter(function(item, index, array) {
    // если true - элемент добавляется к результату, и перебор продолжается
    // возвращается пустой массив в случае, если ничего не найдено
});

const users = [
    {id: 1, name: "Вася"},
    {id: 2, name: "Петя"},
    {id: 3, name: "Маша"}
];
// возвращает массив, состоящий из двух первых пользователей
const someUsers = users.filter(item => item.id < 3);
console.log(someUsers.length); // 2





// Преобразование массива

// map
// синтаксис
const result3 = arr.map(function(item, index, array) {
    // возвращается новое значение вместо элемента
});

// Например, здесь мы преобразуем каждый элемент в его длину:
const lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
console.log(lengths); // 5,7,6




// sort(fn)
// Вызов arr.sort() сортирует массив на месте, меняя в нём порядок элементов.
// Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, так как изменяется сам arr.

const arr7 = [ 1, 2, 15 ];
// метод сортирует содержимое arr7
arr7.sort();
alert( arr7 );  // 1, 15, 2

// Порядок стал 1, 15, 2. Это неправильно! Но почему?
// По умолчанию элементы сортируются как строки.
// Буквально, элементы преобразуются в строки при сравнении.
// Для строк применяется лексикографический порядок, и действительно выходит, что "2" > "15".

// Чтобы использовать наш собственный порядок сортировки,
// нам нужно предоставить функцию в качестве аргумента arr.sort().

arr7.sort( (a, b) => a - b );




// reverse
const arr8 = [1, 2, 3, 4, 5];
arr8.reverse();
alert( arr8 ); // 5,4,3,2,1




// split и join
// Метод str.split(delim) именно это и делает. Он разбивает строку на массив по заданному разделителю delim.
const names = 'Вася, Петя, Маша';
const arr8 = names.split(', ');
for (let name of arr8) {
    alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}




// reduce
// синтаксис:
const value = arr.reduce(function(accumulator, item, index, array) {
    // ...
}, [initial]);

// Функция применяется по очереди ко всем элементам массива и «переносит» свой результат на следующий вызов.

// Аргументы:
// accumulator – результат предыдущего вызова этой функции, равен initial при первом вызове (если передан initial),
// item – очередной элемент массива,
// index – его индекс,
// array – сам массив.

const arr8 = [1, 2, 3, 4, 5];
const result = arr8.reduce((sum, current) => sum + current, 0);
alert(result); // 15





// Array.isArray
// Массивы не образуют отдельный тип языка. Они основаны на объектах.
// Поэтому typeof не может отличить простой объект от массива:
alert(typeof {}); // object
alert(typeof []); // тоже object

alert(Array.isArray({})); // false
alert(Array.isArray([])); // true