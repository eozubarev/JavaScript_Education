// Встроенные прототипы
/*
    Свойство "prototype" широко используется внутри самого языка JavaScript.
    Все встроенные функции-конструкторы используют его.

    Сначала мы рассмотрим детали, а затем используем "prototype"
    для добавления встроенным объектам новой функциональности.
 */

const obj = {};
console.log( obj ); // "[object Object]" ?

// Где код, который генерирует строку "[object Object]"? Это встроенный метод toString, но где он? obj ведь пуст!
// …Но краткая нотация obj = {} – это то же самое, что и obj = new Object(),
// где Object – встроенная функция-конструктор для объектов с собственным свойством prototype,
// которое ссылается на огромный объект с методом toString и другими.

// Таким образом, когда вызывается obj.toString(), метод берётся из Object.prototype.
// Мы можем проверить это так:

const obj2 = {};
console.log(obj2.__proto__ === Object.prototype); // true
// obj.toString === obj.__proto__.toString === Object.prototype.toString





// Другие встроенные прототипы
// Другие встроенные объекты, такие как Array, Date, Function и другие, также хранят свои методы в прототипах.
const arr = [1, 2, 3];

// наследует ли от Array.prototype?
console.log( arr.__proto__ === Array.prototype ); // true

// затем наследует ли от Object.prototype?
console.log( arr.__proto__.__proto__ === Object.prototype ); // true

// и null на вершине иерархии
console.log( arr.__proto__.__proto__.__proto__ ); // null

// Некоторые методы в прототипах могут пересекаться, например, у Array.prototype
// есть свой метод toString, который выводит элементы массива через запятую:

const arr = [1, 2, 3]
console.log(arr); // 1,2,3 <-- результат Array.prototype.toString




// Другие встроенные объекты устроены аналогично.
// Даже функции – они объекты встроенного конструктора Function, и все их методы (call/apply и другие)
// берутся из Function.prototype. Также у функций есть свой метод toString.

function f() {}

console.log(f.__proto__ == Function.prototype); // true
console.log(f.__proto__.__proto__ == Object.prototype); // true, наследует от Object




// Примитивы
// Самое сложное происходит со строками, числами и булевыми значениями.
// Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам,
// то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String, Number и Boolean,
// который предоставит методы и после этого исчезнет.
const str = 'Lorem ipsum dolor sit.';
console.log(str.toUpperCase()); // после того, как интерпретатор увидел точку
// он создал обёртку, по цепочке прототипов нашёл метод toUpperCase(), использовал его и удалил обёртку




// Изменение встроенных прототипов
// Встроенные прототипы можно изменять. Например, если добавить метод к
// String.prototype, метод становится доступен для всех строк:

String.prototype.show = function() {
    console.log(this);
};

"BOOM!".show(); // BOOM!

/*
    Важно:
    Прототипы глобальны, поэтому очень легко могут возникнуть конфликты.
    Если две библиотеки добавляют метод String.prototype.show, то одна из них перепишет метод другой.
    Так что, в общем, изменение встроенных прототипов считается плохой идеей.
 */

// В современном программировании есть только один случай,
// в котором одобряется изменение встроенных прототипов. Это создание полифилов.

if (!String.prototype.repeat) { // Если такого метода нет
                                // добавляем его в прототип

    String.prototype.repeat = function(n) {
        // повторить строку n раз

        // на самом деле код должен быть немного более сложным
        // (полный алгоритм можно найти в спецификации)
        // но даже неполный полифил зачастую достаточно хорош для использования
        return new Array(n + 1).join(this);
    };
}

console.log( "La".repeat(3) ); // LaLaLa






/*
    Заимствование у прототипов

    В главе Декораторы и переадресация вызова, call/apply мы говорили о заимствовании методов.
    Это когда мы берём метод из одного объекта и копируем его в другой.
    Некоторые методы встроенных прототипов часто одалживают.
    Например, если мы создаём объект, похожий на массив (псевдомассив), мы можем скопировать некоторые методы из Array в этот объект.

    Пример:
 */


const obj = {
    0: "Hello",
    1: "world!",
    length: 2,
};

obj.join = Array.prototype.join;

console.log( obj.join(',') ); // Hello,world!